/*
Recibe los dos valores desempilados a operador,
y su respectivo operador, para devolver su valor
y regresarlo a la pila posteriorente en Evaluar_Expresion.
*/
//CAMBIOS EUGENIOSS
void Obtener_Valores();

//float Evaluar_SubExpresiones(float valor1, char operador, float valor2);

/*
Devuelve la potencia; se usa para cuando existe
el operador ^
*/
//float Potencia(float base, float exponente);

/*
Se ayuda de No_Repite, para pedir los valores de la literales una sola vez.
Recibe la cadena de Evaluar_Expresion, no devuelve valores.
*/
//void Obtener_Valores(char *cad_posfija, elemento *diccionario, int *indice_dic);

/*
primer argumeto es el arreglo de solo literales, el segundo el tamaÃ±o del
arreglo literales y el tercero es en donde se guardar el arreglo sin repeticion,
el arreglo sin repeticiones se modifica por referencia por lo tanto no nesecita enviar nada
*/
void No_Repite(char* cadena,int tam,char* resultado);

/*
Elimina el contenido de todos los arreglos usados a lo largo del programa,
para poder analizar una nueva expresiÃ³nd e manera correcta.
*/
//void Vaciar_Arreglos(char *cad, char *cad_posfija, char *literalesDeExpresion, int *valoresDeLiterales, char *auxiliarAntiRepeticion);

void Evaluar_Expresion(char *cad_posfija, float* valoresDeLiterales);/*
Recibe los dos valores desempilados a operador,
y su respectivo operador, para devolver su valor
y regresarlo a la pila posteriorente en Evaluar_Expresion.
*/

void Obtener_Valores();

//float Evaluar_SubExpresiones(float valor1, char operador, float valor2);

/*
Devuelve la potencia; se usa para cuando existe
el operador ^
*/
//float Potencia(float base, float exponente);

/*
Se ayuda de No_Repite, para pedir los valores de la literales una sola vez.
Recibe la cadena de Evaluar_Expresion, no devuelve valores.
*/
//void Obtener_Valores(char *cad_posfija, elemento *diccionario, int *indice_dic);

/*
primer argumeto es el arreglo de solo literales, el segundo el tamaÃ±o del
arreglo literales y el tercero es en donde se guardar el arreglo sin repeticion,
el arreglo sin repeticiones se modifica por referencia por lo tanto no nesecita enviar nada
*/
void No_Repite(char* cadena,int tam,char* resultado);

/*
Elimina el contenido de todos los arreglos usados a lo largo del programa,
para poder analizar una nueva expresiÃ³nd e manera correcta.
*/
//void Vaciar_Arreglos(char *cad, char *cad_posfija, char *literalesDeExpresion, int *valoresDeLiterales, char *auxiliarAntiRepeticion);

void Evaluar_Expresion(char *cad_posfija, float* valoresDeLiterales);/*
Recibe los dos valores desempilados a operador,
y su respectivo operador, para devolver su valor
y regresarlo a la pila posteriorente en Evaluar_Expresion.
*/

void Obtener_Valores();

//float Evaluar_SubExpresiones(float valor1, char operador, float valor2);

/*
Devuelve la potencia; se usa para cuando existe
el operador ^
*/
//float Potencia(float base, float exponente);

/*
Se ayuda de No_Repite, para pedir los valores de la literales una sola vez.
Recibe la cadena de Evaluar_Expresion, no devuelve valores.
*/
//void Obtener_Valores(char *cad_posfija, elemento *diccionario, int *indice_dic);

/*
primer argumeto es el arreglo de solo literales, el segundo el tamaÃ±o del
arreglo literales y el tercero es en donde se guardar el arreglo sin repeticion,
el arreglo sin repeticiones se modifica por referencia por lo tanto no nesecita enviar nada
*/
void No_Repite(char* cadena,int tam,char* resultado);

/*
Elimina el contenido de todos los arreglos usados a lo largo del programa,
para poder analizar una nueva expresiÃ³nd e manera correcta.
*/
//void Vaciar_Arreglos(char *cad, char *cad_posfija, char *literalesDeExpresion, int *valoresDeLiterales, char *auxiliarAntiRepeticion);

void Evaluar_Expresion(char *cad_posfija, float* valoresDeLiterales);
